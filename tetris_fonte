#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define TAM_FILA 5
#define TAM_PILHA 3
#define NUM_TIPOS_PECA 4

typedef struct {
    char nome;
    int id;
} Peca;

typedef struct {
    Peca elementos[TAM_PILHA];
    int topo;
} Pilha;

typedef struct {
    Peca elementos[TAM_FILA];
    int inicio;
    int quantidade;
} Fila;

static int id_global = 0;
static const char TIPOS_PECA[NUM_TIPOS_PECA] = {'I', 'O', 'T', 'L'};

Peca gerarPeca() {
    Peca p = {
        .nome = TIPOS_PECA[rand() % NUM_TIPOS_PECA],
        .id = id_global++
    };
    return p;
}

int pilhaCheia(const Pilha *p) {
    return p->topo >= TAM_PILHA;
}

int pilhaVazia(const Pilha *p) {
    return p->topo == 0;
}

int filaCheia(const Fila *f) {
    return f->quantidade >= TAM_FILA;
}

int filaVazia(const Fila *f) {
    return f->quantidade == 0;
}

void inicializarFila(Fila *f) {
    f->inicio = 0;
    f->quantidade = 0;
    
    for (int i = 0; i < TAM_FILA; i++) {
        f->elementos[i] = gerarPeca();
        f->quantidade++;
    }
}

void inicializarPilha(Pilha *p) {
    p->topo = 0;
}

int enqueue(Fila *f, Peca p) {
    if (filaCheia(f)) {
        return 0;
    }
    
    int posicao = (f->inicio + f->quantidade) % TAM_FILA;
    f->elementos[posicao] = p;
    f->quantidade++;
    return 1;
}

int dequeue(Fila *f, Peca *p) {
    if (filaVazia(f)) {
        return 0;
    }
    
    *p = f->elementos[f->inicio];
    f->inicio = (f->inicio + 1) % TAM_FILA;
    f->quantidade--;
    return 1;
}

int push(Pilha *p, Peca peca) {
    if (pilhaCheia(p)) {
        return 0;
    }
    
    p->elementos[p->topo++] = peca;
    return 1;
}

int pop(Pilha *p, Peca *peca) {
    if (pilhaVazia(p)) {
        return 0;
    }
    
    p->topo--;
    *peca = p->elementos[p->topo];
    return 1;
}

Peca* obterElementoFila(Fila *f, int indice) {
    if (indice >= f->quantidade) {
        return NULL;
    }
    int posicao = (f->inicio + indice) % TAM_FILA;
    return &f->elementos[posicao];
}

void exibirEstado(const Fila *f, const Pilha *p) {
    printf("\n==========================================\n");
    printf("         ESTADO ATUAL DO JOGO          \n");
    printf("==========================================\n");
    
    printf("\nFila de pecas: ");
    for (int i = 0; i < f->quantidade; i++) {
        int pos = (f->inicio + i) % TAM_FILA;
        printf("[%c %d] ", f->elementos[pos].nome, f->elementos[pos].id);
    }
    
    printf("\n\nPilha de reserva (Topo -> Base): ");
    if (pilhaVazia(p)) {
        printf("Vazia");
    } else {
        for (int i = p->topo - 1; i >= 0; i--) {
            printf("[%c %d] ", p->elementos[i].nome, p->elementos[i].id);
        }
    }
    printf("\n\n");
}

int jogarPeca(Fila *f) {
    Peca p;
    if (!dequeue(f, &p)) {
        printf("\n>> ERRO: Fila vazia!\n");
        return 0;
    }
    
    printf("\n>> Peca [%c %d] jogada!\n", p.nome, p.id);
    
    Peca nova = gerarPeca();
    enqueue(f, nova);
    
    return 1;
}

int reservarPeca(Fila *f, Pilha *p) {
    if (pilhaCheia(p)) {
        printf("\n>> ERRO: Pilha de reserva cheia!\n");
        return 0;
    }
    
    Peca peca;
    if (!dequeue(f, &peca)) {
        printf("\n>> ERRO: Fila vazia!\n");
        return 0;
    }
    
    push(p, peca);
    printf("\n>> Peca [%c %d] reservada!\n", peca.nome, peca.id);
    
    Peca nova = gerarPeca();
    enqueue(f, nova);
    
    return 1;
}

int usarPecaReservada(Pilha *p) {
    if (pilhaVazia(p)) {
        printf("\n>> ERRO: Nenhuma peca na reserva!\n");
        return 0;
    }
    
    Peca peca;
    pop(p, &peca);
    printf("\n>> Peca da reserva [%c %d] utilizada!\n", peca.nome, peca.id);
    
    return 1;
}

int trocarPecaAtual(Fila *f, Pilha *p) {
    if (pilhaVazia(p)) {
        printf("\n>> ERRO: Pilha vazia, impossivel trocar!\n");
        return 0;
    }
    
    if (filaVazia(f)) {
        printf("\n>> ERRO: Fila vazia, impossivel trocar!\n");
        return 0;
    }
    
    Peca *frenteFila = obterElementoFila(f, 0);
    Peca temp = *frenteFila;
    *frenteFila = p->elementos[p->topo - 1];
    p->elementos[p->topo - 1] = temp;
    
    printf("\n>> Troca realizada entre fila e topo da pilha!\n");
    return 1;
}

int trocaMultipla(Fila *f, Pilha *p) {
    if (!pilhaCheia(p)) {
        printf("\n>> ERRO: Necessario ter 3 pecas na pilha para troca multipla!\n");
        return 0;
    }
    
    if (f->quantidade < 3) {
        printf("\n>> ERRO: Necessario ter 3 pecas na fila para troca multipla!\n");
        return 0;
    }
    
    for (int i = 0; i < TAM_PILHA; i++) {
        Peca *elementoFila = obterElementoFila(f, i);
        Peca temp = *elementoFila;
        *elementoFila = p->elementos[TAM_PILHA - 1 - i];
        p->elementos[TAM_PILHA - 1 - i] = temp;
    }
    
    printf("\n>> Troca multipla realizada com sucesso!\n");
    return 1;
}

void exibirMenu() {
    printf("==========================================\n");
    printf("           OPCOES DE ACAO              \n");
    printf("==========================================\n");
    printf(" 1 - Jogar peca (dequeue)              \n");
    printf(" 2 - Reservar peca (push)              \n");
    printf(" 3 - Usar peca reservada (pop)         \n");
    printf(" 4 - Trocar peca atual (swap)          \n");
    printf(" 5 - Troca multipla (3x3 swap)         \n");
    printf(" 0 - Sair                              \n");
    printf("==========================================\n");
    printf("Opcao: ");
}

int lerOpcao() {
    int opcao;
    if (scanf("%d", &opcao) != 1) {
        while (getchar() != '\n');
        return -1;
    }
    return opcao;
}

void executarAcao(int opcao, Fila *f, Pilha *p, int *continuar) {
    switch (opcao) {
        case 1:
            jogarPeca(f);
            break;
        case 2:
            reservarPeca(f, p);
            break;
        case 3:
            usarPecaReservada(p);
            break;
        case 4:
            trocarPecaAtual(f, p);
            break;
        case 5:
            trocaMultipla(f, p);
            break;
        case 0:
            printf("\n>> Encerrando Tetris Stack. Ate logo!\n\n");
            *continuar = 0;
            break;
        default:
            printf("\n>> ERRO: Opcao invalida! Tente novamente.\n");
    }
}

int main() {
    srand(time(NULL));
    
    Fila fila;
    Pilha pilha;
    int continuar = 1;
    
    inicializarFila(&fila);
    inicializarPilha(&pilha);
    
    printf("\n==========================================\n");
    printf("      BEM-VINDO AO TETRIS STACK!       \n");
    printf("==========================================\n");
    
    while (continuar) {
        exibirEstado(&fila, &pilha);
        exibirMenu();
        int opcao = lerOpcao();
        executarAcao(opcao, &fila, &pilha, &continuar);
    }
    
    return 0;
}
